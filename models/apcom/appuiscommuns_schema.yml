version: 2


# tests génériques de contrainte de schéma pour le modèle de données du cas d'usage "appuis communs"
models:
  - name: osm_posup__apcom_supportaerien__expected_stg
    description: "TODO move test unitaire en --target test de transformation (normalisation) : attendu préparé portant la définition du test unitaire et permettant de la désactiver"
    # (sinon laisser le test mais le comparer avec le même plutôt que le réel, mais ça laisse un test dépourvu de sens)
    config:
      tags: ['expected', 'test'] # 'pii' TODO generate from ....sql (and rename it)
      enabled: "{{ target.name == 'test' }}"
    tests:
      - dbt_utils.equality:
          compare_model: ref('osm_powsupp__appuiscommuns_supportaerien') # TODO sur exemple démarqué, une fois --target fini ; PAS directement __expected pour gérer le parsing nécessaire (uuid... ; le même code sert à charger les exemples embarqués ex. __definition, donc mieux qu'en sens inverse) ; TODO déplacer sur la normalization mais comme elle a des champs propres pour l'instant ici (qui a en plus le champ _dbt_source_relation)
  - name: appuiscommuns_supportaerien
    description: l'union des supportaerien des toutes les sources
    config:
      tags: ['unification'] # 'pii' TODO generate from source__type.sql (and rename it)
    #tests:
    #  - dbt_utils.equality:
    #      compare_model: ref('osm_posup__apcom_supportaerien__expected_stg') # TODO sur exemple démarqué, une fois --target fini ; PAS directement __expected pour gérer le parsing nécessaire (uuid... ; le même code sert à charger les exemples embarqués ex. __definition, donc mieux qu'en sens inverse) ; TODO déplacer sur la normalization mais comme elle a des champs propres pour l'instant ici (qui a en plus le champ _dbt_source_relation)
    columns:
      - name: appuiscommunssupp__src_name
        description: le nom de la source ("table lineage", DBT peut aussi le rajouter)
        tests:
          - not_null
      - name: appuiscommunssupp__src_id
        description: id de la donnée spécifique à la source
        tags: ['id', 'unique'] # 'pii' TODO generate from profiling, generate also in source or seed
        tests:
          - unique
          - not_null
      - name: '"appuiscommunssupp__Id"'
        description: id (uuid)
        tags: ['id', 'unique', 'uuid'] # 'pii' TODO generate from profiling & syntax
        tests:
          - unique
          - not_null
      - name: geometry
        tests:
          - unique
          - not_null
      - name: '"appuiscommunssupp__CodeExterne"'
        #description:
        tests:
          - dbt_expectations.expect_column_values_to_be_of_type:
              column_type: text # TODO Alphanumérique trop contraint (-) ?
          - dbt_expectations.expect_column_values_to_match_regex:
              regex: "^[a-zA-Z0-9]*$" # if also unicode : "^[\\p{L}0-9]*$";
      - name: '"appuiscommunssupp__Materiau"'
        tags: ['l_appuisaeriens_materiau'] # TODO better naming allowing to generate relationships test and (?) (_)_enriched.sql model, generate from type_definition column name
        tests:
          - relationships:
              to: ref("l_appuisaeriens_materiau")
              field: '"Valeur"'
      - name: '"appuiscommunssupp__Nature"'
        tags: ['l_pointaccueil_nature'] # TODO better naming allowing to generate relationships test and (?) (_)_enriched.sql model, generate from type_definition column name
        tests:
          - relationships:
              to: ref("l_pointaccueil_nature__mapping")
              field: '"appuiscommunssupp__Nature"'
      - name: '"appuiscommunssupp__HauteurAppui"'
        tests:
          - dbt_utils.accepted_range:
              min_value: 0 # 1 ?
              max_value: 100 # 97
              #where: "appuiscommunssupp__HauteurAppui > 0"
      - name: appuiscommunssupp__fdrcommune__insee_id
        tags: ['fdrcommune__insee_id'] # TODO generate relationships test and (?) (_)_enriched.sql model, generate from type_definition column name
        tests:
          - not_null
          - relationships:
              to: source("france-data-reseau", "georef-france-commune.csv")
              field: '"com_code"'
              #description: 'zzztest' # KO macro 'dbt_macro__test_relationships' takes no keyword argument 'description'
              config:
                #description: 'tttest' # KO not seen in docs UI
                where: "\"appuiscommunssupp__fdrcommune__insee_id\" not in ('ko', '98712', '98715', '98722', '98725', '98729', '98735', '98738', '98747', '98752', '98802', '98803', '98805', '98807', '98808', '98810', '98811', '98812', '98813', '98816', '98817', '98818', '98821', '98825', '98826', '98827', '98828', '98829', '98831', '98832', '98833')"
  - name: osm_powsupp__appuiscommuns_supportaerien
    description: la normalisation en supportaerien de la source ...extract...
    config:
      tags: ['normalization', 'transformation'] # 'pii' TODO generate from source__type.sql (and rename it)
      meta: { "type" : "supportaerien" } # TODO definition: _definition ou de type ou invt., source/in: osm_
    #columns:
    #  - name: appuiscommunssupp__src_name # required else model tests below not run !?!
    #tests:
    #  - dbt_utils.equality:
    #      compare_model: ref('osm_powersupports__supportaerien__expected_stg') # TODO sur exemple démarqué, une fois --target fini ; PAS directement __expected pour gérer le parsing nécessaire (uuid... ; le même code sert à charger les exemples embarqués ex. __definition, donc mieux qu'en sens inverse) ; MAIS pb
  - name: birdz__apcom_supportaerien__expected_stg
    description: "test unitaire en --target test de transformation (normalisation) : attendu préparé portant la définition du test unitaire et permettant de la désactiver"
    # (sinon laisser le test mais le comparer avec le même plutôt que le réel, mais ça laisse un test dépourvu de sens)
    config:
      tags: [ 'expected', 'test' ] # 'pii' TODO generate from ....sql (and rename it)
      enabled: "{{ target.name == 'test' }}"
    tests:
      - dbt_utils.equality:
          compare_model: ref('birdz__apcom_supportaerien') # TODO sur exemple démarqué, une fois --target fini ; PAS directement __expected pour gérer le parsing nécessaire (uuid... ; le même code sert à charger les exemples embarqués ex. __definition, donc mieux qu'en sens inverse) ; TODO déplacer sur la normalization mais comme elle a des champs propres pour l'instant ici (qui a en plus le champ _dbt_source_relation)

seeds:
  #- name: appuiscommuns_supportaerien__definition
  #  description: définition formelle du type supportaerien (pour l'instant copié manuellement depuis le Gitbook, à terme pourrait générer ce dernier voire un métamodèle guidant l'outillage)
  #  config:
  #    tags: ["definition"]
  #    meta: { "type" : "supportaerien" }
  - name: appuiscommuns_supportaerien__example
    description: "Parsing of a priori (made-up), covering examples of the definition / interface.
      Examples have to be **as representative** of all possible data as possible because they are also the basis of the definition.
      For instance, for a commune INSEE id field, they should also include a non-integer value such as 2A035 (Belvédère-Campomoro).
      Methodology :
      1. copy the first line(s) from the specification document (pour l'instant copié manuellement depuis le Gitbook, à terme pourrait générer ce dernier voire un métamodèle guidant l'outillage)
      2. add line(s) to contain further values for until they are covering for all columns
      3. NB. examples specific to each source type are provided in _source_example along their implementation (for which they are covering)"
    config:
      tags: ["example"] # echantillon, test
      meta: { "type" : "supportaerien" }
      column_types:
        appuiscommunssupp__HauteurAppui: text
  - name : osmgeodatamine_powersupports_extract
    description: extrait représentatif des données de la source (type) osmgeodatamine_powersupports
    config:
      tags: ["sample", "extract"]
      column_types:
        com_insee: text # sinon integer et le code 01001 devient 1001
    #  "Libell\xE9_d_acheminement": text
  - name : osm_posup__apcom_supportaerien__expected
    description: attendu de la normalisation osmps
    config:
      tags: ["unittest", "expected"]
      column_types:
        # (anyway all should be read as text by dbt seed)
        appuiscommunssupp__commune_insee_id: text # sinon integer et le code 01001 devient 1001
        fdrcommune__insee_id: text # sinon integer et le code 01001 devient 1001
        appuiscommunssupp__fdrcommune__insee_id: text # sinon integer et le code 01001 devient 1001
  - name: l_appuisaeriens_materiau
    description: liste de valeurs possibles pour le champ
    config:
      tags: ["dictionary"]
  - name: l_pointaccueil_nature
    config:
      tags: ["dictionary"]
  - name: l_pointaccueil_nature__mapping
    description: table de traduction / réconciliation de la liste de valeurs depuis la source (jeu / org)
    config:
      tags: ["dictionary", "mapping"]
  - name: l_appuisaeriens_materiau__osmgeodatamine
    description: table de traduction / réconciliation de la liste de valeurs depuis la source (jeu / org) osmgeodatamine
    config:
      tags: ["link", "mapping"]
  - name : birdz_supportaerien_example
    description: extrait représentatif des données de la source (type) birdz
    config:
      tags: ["sample", "example"]
      column_types:
        # (anyway all should be read as text by dbt seed)
        "PDR_NUM,C,254": text # sinon 29051_00040 lu comme 2905100040 (!), type détecté comme integer et erreur integer out of range
        "ADR_POS_X,C,254": text # car contient ',' sinon lu à l'anglaise
        "ADR_POS_Y,C,254": text # car contient ',' sinon lu à l'anglaise
  - name: birdz__apcom_supportaerien__expected
    description: attendu de la normalisation birdz
    config:
      tags: [ "unittest", "expected" ]
      column_types:
        # (anyway all should be read as text by dbt seed)
        appuiscommunssupp__src_id: text # sinon integer out of range because dbt agate skips middle _
        appuiscommunssupp__commune_insee_id: text # sinon integer et le code 01001 devient 1001
        fdrcommune__insee_id: text # sinon integer et le code 01001 devient 1001
        appuiscommunssupp__fdrcommune__insee_id: text # sinon integer et le code 01001 devient 1001